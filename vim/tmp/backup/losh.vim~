" .ivzep
" Nhgube: Fgrir Ybfu <fgrir@fgrirybfu.pbz>
" Fbhepr: uggc://ovgohpxrg.bet/fwy/qbgsvyrf/fep/gvc/ivz/
"
" Guvf svyr punatrf n ybg.  V'yy gel gb qbphzrag cvrprf bs vg jurarire V unir
" n srj zvahgrf gb xvyy.

" Cernzoyr ---------------------------------------------------------------- {{{

" Qrne /ova/onfu: shpx lbh naq lbhe ohyyfuvg, nepnar pbzznaq-yvar orunivbhe.
"
" Onfvpnyyl, V jnag gb frg guvf gb n aba-ybtva, aba-vagrenpgvir onfu furyy.
" Hfvat n ybtva/vagrenpgvir onfu nf Ivz'f 'furyy' oernxf fhogyr guvatf, yvxr
" npx.ivz'f pbzznaq-yvar nethzrag cnefvat.  Ubjrire, V *qb* jnag onfu gb ybnq
" ~/.onfu_cebsvyr fb zl nyvnfrf trg ybnqrq naq fhpu.
"
" Lbh zvtug guvax lbh pbhyq qb guvf jvgu gur --vavg-svyr pbzznaq yvar bcgvba,
" juvpu vf hfrq gb fcrpvsl na vavg svyr.  Be jvgu --epsvyr.  Ohg ab, gubfr bayl
" trg ybnqrq sbe vagrenpgvir/ybtva furyyf.
"
" Fb ubj qb jr gryy onfu gb fbhepr n tbqqnzarq svyr jura vg ybnqf?  Jvgu na
" *raivebazrag inevnoyr*.  Wrfhf, lbh unir zhygvcyr pbzznaq yvar bcgvbaf sbe
" fcrpvslvat svyrf gb ybnq naq abar bs gurz jbex?
"
" Pbzchgref ner ohyyfuvg.
yrg $ONFU_RAI = "~/.onfu_cebsvyr"
frg furyy=/ova/onfu

svyrglcr bss
pnyy cngubtra#vasrpg()
svyrglcr cyhtva vaqrag ba
frg abpbzcngvoyr

" }}}
" Onfvp bcgvbaf ----------------------------------------------------------- {{{

frg rapbqvat=hgs-8
frg zbqryvarf=0
frg nhgbvaqrag
frg fubjzbqr
frg fubjpzq
frg uvqqra
frg ivfhnyoryy
frg gglsnfg
frg ehyre
frg onpxfcnpr=vaqrag,rby,fgneg
frg abahzore
frg aberyngvirahzore
frg ynfgfgnghf=2
frg uvfgbel=1000
frg haqbsvyr
frg haqberybnq=10000
frg yvfg
frg yvfgpunef=gno:â–¸\ ,rby:Â¬,rkgraqf:â¯,cerprqrf:â®
frg ynmlerqenj
frg zngpugvzr=3
frg fubjoernx=â†ª
frg fcyvgorybj
frg fcyvgevtug
frg nhgbjevgr
frg nhgbernq
frg fuvsgebhaq
frg gvgyr
frg yvaroernx
frg pbybepbyhza=+1

" Fcryyvat
"
" Gurer ner guerr qvpgvbanevrf V hfr sbe fcryypurpxvat:
"
"   /hfe/funer/qvpg/jbeqf
"   Onfvp fghss.
"
"   ~/.ivz/phfgbz-qvpgvbanel.hgs-8.nqq
"   Phfgbz jbeqf (yvxr zl anzr).  Guvf vf va zl (irefvba-pbagebyyrq) qbgsvyrf.
"
"   ~/.ivz-ybpny-qvpgvbanel.hgs-8.nqq
"   Zber phfgbz jbeqf.  Guvf vf *abg* irefvba pbagebyyrq, fb V pna fgvpx
"   jbex fghss va urer jvgubhg yrnxvat vagreany anzrf naq fuvg.
"
" V nyfb erznc mT gb nqq gb gur ybpny qvpg (inavyyn mT vf hfryrff naljnl).
frg qvpgvbanel=/hfe/funer/qvpg/jbeqf
frg fcryysvyr=~/.ivz/phfgbz-qvpgvbanel.hgs-8.nqq,~/.ivz-ybpny-qvpgvbanel.hgs-8.nqq
aaberznc mT 2mt

" vGrez2 vf pheeragyl fybj nf onyyf ng eraqrevat gur avpr havpbqr yvarf, fb sbe
" abj V'yy whfg hfr NFPVV cvcrf.  Gurl'er htyl ohg ng yrnfg V jba'g jnag gb xvyy
" zlfrys jura gelvat gb zbir nebhaq n svyr.
frg svyypunef=qvss:â£¿,ireg:â”‚
frg svyypunef=qvss:â£¿,ireg:\|

" Qba'g gel gb uvtuyvtug yvarf ybatre guna 800 punenpgref.
frg flaznkpby=800

" Gvzr bhg ba xrl pbqrf ohg abg znccvatf.
" Onfvpnyyl guvf znxrf grezvany Ivz jbex fnaryl.
frg abgvzrbhg
frg ggvzrbhg
frg ggvzrbhgyra=10

" Znxr Ivz noyr gb rqvg pebagno svyrf ntnva.
frg onpxhcfxvc=/gzc/*,/cevingr/gzc/*"

" Orggre Pbzcyrgvba
frg pbzcyrgr=.,j,o,h,g
frg pbzcyrgrbcg=ybatrfg,zrahbar,cerivrj

" Fnir jura ybfvat sbphf
nh SbphfYbfg * :fvyrag! jnyy

" Erfvmr fcyvgf jura gur jvaqbj vf erfvmrq
nh IvzErfvmrq * :jvapzq =

" Yrnqre
yrg zncyrnqre = ","
yrg zncybpnyyrnqre = "\\"

" Phefbeyvar {{{
" Bayl fubj phefbeyvar va gur pheerag jvaqbj naq va abezny zbqr.

nhtebhc pyvar
    nh!
    nh JvaYrnir,VafregRagre * frg abphefbeyvar
    nh JvaRagre,VafregYrnir * frg phefbeyvar
nhtebhc RAQ

" }}}
" pcbcgvbaf+=W, qnzzvg {{{

" Fbzrguvat bppnfvbanyyl erzbirf guvf.  Vs V znantr gb svaq vg V'z tbvat gb
" pbzzrag bhg gur yvar naq ercynpr nyy vgf punenpgref jvgu 'SHPX'.
nhtebhc gjbfcnpr
    nh!
    nh OhsErnq * :frg pcbcgvbaf+=W
nhtebhc RAQ

" }}}
" Genvyvat juvgrfcnpr {{{
" Bayl fubja jura abg va vafreg zbqr fb V qba'g tb vafnar.

nhtebhc genvyvat
    nh!
    nh VafregRagre * :frg yvfgpunef-=genvy:âŒ´
    nh VafregYrnir * :frg yvfgpunef+=genvy:âŒ´
nhtebhc RAQ

" }}}
" Jvyqzrah pbzcyrgvba {{{

frg jvyqzrah
frg jvyqzbqr=yvfg:ybatrfg

frg jvyqvtaber+=.ut,.tvg,.fia                    " Irefvba pbageby
frg jvyqvtaber+=*.nhk,*.bhg,*.gbp                " YnGrK vagrezrqvngr svyrf
frg jvyqvtaber+=*.wct,*.ozc,*.tvs,*.cat,*.wcrt   " ovanel vzntrf
frg jvyqvtaber+=*.b,*.bow,*.rkr,*.qyy,*.znavsrfg " pbzcvyrq bowrpg svyrf
frg jvyqvtaber+=*.fcy                            " pbzcvyrq fcryyvat jbeq yvfgf
frg jvyqvtaber+=*.fj?                            " Ivz fjnc svyrf
frg jvyqvtaber+=*.QF_Fgber                       " BFK ohyyfuvg

frg jvyqvtaber+=*.yhnp                           " Yhn olgr pbqr

frg jvyqvtaber+=zvtengvbaf                       " Qwnatb zvtengvbaf
frg jvyqvtaber+=*.clp                            " Clguba olgr pbqr

frg jvyqvtaber+=*.bevt                           " Zretr erfbyhgvba svyrf

" Pybwher/Yrvavatra
frg jvyqvtaber+=pynffrf
frg jvyqvtaber+=yvo

" }}}
" Yvar Erghea {{{

" Znxr fher Ivz ergheaf gb gur fnzr yvar jura lbh erbcra n svyr.
" Gunaxf, Nzvg
nhtebhc yvar_erghea
    nh!
    nh OhsErnqCbfg *
        \ vs yvar("'\"") > 0 && yvar("'\"") <= yvar("$") |
        \     rkrphgr 'abezny! t`"mimm' |
        \ raqvs
nhtebhc RAQ

" }}}
" Gnof, fcnprf, jenccvat {{{

frg gnofgbc=8
frg fuvsgjvqgu=4
frg fbsggnofgbc=4
frg rkcnaqgno
frg jenc
frg grkgjvqgu=80
frg sbezngbcgvbaf=dea1w
frg pbybepbyhza=+1

" }}}
" Onpxhcf {{{

frg onpxhc                        " ranoyr onpxhcf
frg abfjncsvyr                    " vg'f 2013, Ivz.

frg haqbqve=~/.ivz/gzc/haqb//     " haqb svyrf
frg onpxhcqve=~/.ivz/gzc/onpxhc// " onpxhcf
frg qverpgbel=~/.ivz/gzc/fjnc//   " fjnc svyrf

" Znxr gubfr sbyqref nhgbzngvpnyyl vs gurl qba'g nyernql rkvfg.
vs !vfqverpgbel(rkcnaq(&haqbqve))
    pnyy zxqve(rkcnaq(&haqbqve), "c")
raqvs
vs !vfqverpgbel(rkcnaq(&onpxhcqve))
    pnyy zxqve(rkcnaq(&onpxhcqve), "c")
raqvs
vs !vfqverpgbel(rkcnaq(&qverpgbel))
    pnyy zxqve(rkcnaq(&qverpgbel), "c")
raqvs

" }}}
" Pbybe fpurzr {{{

flagnk ba
frg onpxtebhaq=qnex
yrg t:onqjbys_gnoyvar = 2
yrg t:onqjbys_ugzy_yvax_haqreyvar = 0
pbybefpurzr onqjbys

" Erybnq gur pbybefpurzr jurarire jr jevgr gur svyr.
nhtebhc pbybe_onqjbys_qri
    nh!
    nh OhsJevgrCbfg onqjbys.ivz pbybe onqjbys
nhtebhc RAQ

" Uvtuyvtug IPF pbasyvpg znexref
zngpu ReebeZft '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" }}}

" }}}
" Nooerivngvbaf ----------------------------------------------------------- {{{

shapgvba! RngPune(cng)
    yrg p = ae2pune(trgpune(0))
    erghea (p =~ n:cng) ? '' : p
raqshapgvba

shapgvba! ZnxrFcnpryrffVnooeri(sebz, gb)
    rkrphgr "vnooeri <fvyrag> ".n:sebz." ".n:gb."<P-E>=RngPune('\\f')<PE>"
raqshapgvba
shapgvba! ZnxrFcnpryrffOhssreVnooeri(sebz, gb)
    rkrphgr "vnooeri <fvyrag> <ohssre> ".n:sebz." ".n:gb."<P-E>=RngPune('\\f')<PE>"
raqshapgvba

pnyy ZnxrFcnpryrffVnooeri('fy/',  'uggc://fgrirybfu.pbz/')
pnyy ZnxrFcnpryrffVnooeri('oo/',  'uggc://ovgohpxrg.bet/')
pnyy ZnxrFcnpryrffVnooeri('oof/', 'uggc://ovgohpxrg.bet/fwy/')
pnyy ZnxrFcnpryrffVnooeri('tu/',  'uggc://tvguho.pbz/')
pnyy ZnxrFcnpryrffVnooeri('tuf/', 'uggc://tvguho.pbz/fwy/')

vnooeri yqvf à² _à² 
vnooeri yfnq à²¥_à²¥
vnooeri yunc à²¥â€¿à²¥
vnooeri yzvf à² â€¿à² 

vnooeri fy@ fgrir@fgrirybfu.pbz
vnooeri ieps `~/.ivzep` svyr

vnooeri cps Cnegvpvcngbel Phygher Sbhaqngvba

" }}}
" Pbairavrapr znccvatf ---------------------------------------------------- {{{

" Shpx lbh, uryc xrl.
aberznc  <S1> :purpxgvzr<pe>
vaberznc <S1> <rfp>:purpxgvzr<pe>

" Fgbc vg, unfu xrl.
vaberznc # K<OF>#

" Xvyy jvaqbj
aaberznc X :d<pe>

" Zna
aaberznc Z X

" Gbttyr yvar ahzoref
aaberznc <yrnqre>a :frgybpny ahzore!<pe>

" Fbeg yvarf
aaberznc <yrnqre>f ivc:!fbeg<pe>
iaberznc <yrnqre>f :!fbeg<pe>

" Gnof
aaberznc <yrnqre>( :gnoceri<pe>
aaberznc <yrnqre>) :gnoarkg<pe>

" Jenc
aaberznc <yrnqre>J :frg jenc!<pe>

" Pbclvat grkg gb gur flfgrz pyvcobneq.
"
" Sbe fbzr ernfba Ivz ab ybatre jnagf gb gnyx gb gur BF K cnfgrobneq guebhtu "*.
" Pbzchgref ner ohyyfuvg.
shapgvba! t:ShpxvatPbclGurGrkgCyrnfr()
    yrg byq_m = @m
    abezny! ti"ml
    pnyy flfgrz('copbcl', @m)
    yrg @m = byq_m
raqshapgvba
aberznc <yrnqre>c :fvyrag! frg cnfgr<PE>"*c:frg abcnfgr<PE>
" aberznc <yrnqre>c zm:e!cocnfgr<pe>`m
iaberznc <yrnqre>l :<p-h>pnyy t:ShpxvatPbclGurGrkgCyrnfr()<pe>

" V pbafgnagyl uvg "h" va ivfhny zbqr jura V zrna gb "l". Hfr "th" sbe gubfr ener bppnfvbaf.
" Sebz uggcf://tvguho.pbz/uraevx/qbgsvyrf/oybo/znfgre/ivz/pbasvt/znccvatf.ivz
iaberznc h <abc>
iaberznc th h

" Erohvyq Pgntf (zarzbavp EP -> PE -> <pe>)
aaberznc <yrnqre><pe> :fvyrag !zlpgntf >/qri/ahyy 2>&1 &<pe>:erqenj!<pe>

" Uvtuyvtug Tebhc(f)
aaberznc <S8> :rpub "uv<" . flaVQngge(flaVQ(yvar("."),pby("."),1),"anzr") . '> genaf<'
                        \ . flaVQngge(flaVQ(yvar("."),pby("."),0),"anzr") . "> yb<"
                        \ . flaVQngge(flaVQgenaf(flaVQ(yvar("."),pby("."),1)),"anzr") . ">"<PE>

" Pyrna genvyvat juvgrfcnpr
aaberznc <yrnqre>jj zm:%f/\f\+$//<pe>:yrg @/=''<pe>`m

" Fraq ivfhny fryrpgvba gb cnfgr.fgrirybfu.pbz
iaberznc <p-c> :j !phey -fS 'fcehatr=<-' 'uggc://cnfgr.fgrirybfu.pbz' \| ge -q '\a ' \| copbcl && bcra `cocnfgr`<pe>

" Fryrpg ragver ohssre
aaberznc inn ttiTt_
aaberznc Inn ttIT

" "Hccrepnfr jbeq" znccvat.
"
" Guvf znccvat nyybjf lbh gb cerff <p-h> va vafreg zbqr gb pbaireg gur pheerag
" jbeq gb hccrepnfr.  Vg'f unaql jura lbh'er jevgvat anzrf bs pbafgnagf naq
" qba'g jnag gb hfr Pncfybpx.
"
" Gb hfr vg lbh glcr gur anzr bs gur pbafgnag va ybjrepnfr.  Juvyr lbhe
" phefbe vf ng gur raq bs gur jbeq, cerff <p-h> gb hccrepnfr vg, naq gura
" pbagvahr unccvyl ba lbhe jnl:
"
"                            phefbe
"                            i
"     znk_pbaarpgvbaf_nyybjrq|
"     <p-h>
"     ZNK_PBAARPGVBAF_NYYBJRQ|
"                            ^
"                            phefbe
"
" Vg jbexf ol rkvgvat bhg bs vafreg zbqr, erpbeqvat gur pheerag phefbe ybpngvba
" va gur m znex, hfvat tHvj gb hccrepnfr vafvqr gur pheerag jbeq, zbivat onpx gb
" gur m znex, naq ragrevat vafreg zbqr ntnva.
"
" Abgr gung guvf jvyy birejevgr gur pbagragf bs gur m znex.  V arire hfr vg, ohg
" vs lbh qb lbh'yy cebonoyl jnag gb hfr nabgure znex.
vaberznc <P-h> <rfp>zmtHvj`mn

" Cnavp Ohggba
aaberznc <s9> zmttt?T`m

" mg vf bxnl sbe chggvat fbzrguvat ng gur gbc bs gur fperra, ohg jura V'z
" jevgvat cebfr V bsgra jnag gb chg fbzrguvat ng abg-dhvgr-gur-gbc bs gur
" screen.  zh is "zoom to head level"
nnoremap zh mzzt10<c-u>`z

" Diffoff
nnoremap <leader>D :diffoff!<cr>

" Formatting, TextMate-style
nnoremap Q gqip
vnoremap Q gq

" Reformat line.
" I never use l as a macro register anyway.
nnoremap ql gqq

" Easier linewise reselection of what you just pasted.
nnoremap <leader>V V`]

" Indent/dedent/autoindent what you just pasted.
nnoremap <lt>> V`]<
nnoremap ><lt> V`]>
nnoremap =- V`]=

" Keep the cursor in place while joining lines
nnoremap J mzJ`z

" Join an entire paragraph.
"
" Useful for writing GitHub comments in actual Markdown and then translating it
" to their bastardized version of Markdown.
nnoremap <leader>J mzvipJ`z

" Split line (sister to [J]oin lines)
" The normal use of S is covered by cc, so don't worry about shadowing it.
nnoremap S i<cr><esc>^mwgk:silent! s/\v +$//<cr>:noh<cr>`w

" HTML tag closing
inoremap <C-_> <space><bs><esc>:call InsertCloseTag()<cr>a

" Source
vnoremap <leader>S y:execute @@<cr>:echo 'Sourced selection.'<cr>
nnoremap <leader>S ^vg_y:execute @@<cr>:echo 'Sourced line.'<cr>

" Marks and Quotes
noremap ' `
noremap Ã¦ '
noremap ` <C-^>

" Select (charwise) the contents of the current line, excluding indentation.
" Great for pasting Python lines into REPLs.
nnoremap vv ^vg_

" Sudo to write
cnoremap w!! w !sudo tee % >/dev/null

" Typos
command! -bang E e<bang>
command! -bang Q q<bang>
command! -bang W w<bang>
command! -bang QA qa<bang>
command! -bang Qa qa<bang>
command! -bang Wa wa<bang>
command! -bang WA wa<bang>
command! -bang Wq wq<bang>
command! -bang WQ wq<bang>

" I suck at typing.
vnoremap - =

" Toggle paste
" For some reason pastetoggle doesn't redraw the screen (thus the status bar
" doesn't change) while :set paste! does, so I use that instead.
" set pastetoggle=<F6>
nnoremap <F6> :set paste!<cr>

" Toggle [i]nvisible characters
nnoremap <leader>i :set list!<cr>

" Unfuck my screen
nnoremap U :syntax sync fromstart<cr>:redraw!<cr>

" Pushing
nnoremap <leader>Go :Start! git push origin<cr>
nnoremap <leader>Gu :Start! git push upstream<cr>
nnoremap <leader>Hd :Start! hg push default<cr>
nnoremap <leader>Hu :Start! hg push upstream<cr>

" Zip Right
"
" Moves the character under the cursor to the end of the line.  Handy when you
" have something like:
"
"     foo
"
" And you want to wrap it in a method call, so you type:
"
"     println()foo
"
" Once you hit escape your cursor is on the closing paren, so you can 'zip' it
" over to the right with this mapping.
"
" This should preserve your last yank/delete as well.
nnoremap zl :let @z=@"<cr>x$p:let @"=@z<cr>

" Ranger
nnoremap <leader>r :silent !ranger %:h<cr>:redraw!<cr>
nnoremap <leader>R :silent !ranger<cr>:redraw!<cr>

" Insert Mode Completion {{{

inoremap <c-f> <c-x><c-f>
inoremap <c-]> <c-x><c-]>
inoremap <c-l> <c-x><c-l>

" }}}

" }}}
" Quick editing ----------------------------------------------------------- {{{

nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>eV :vsplit scp://vagrant//<cr>
nnoremap <leader>ef :vsplit ~/.config/fish/config.fish<cr>
nnoremap <leader>ed :vsplit ~/.vim/custom-dictionary.utf-8.add<cr>
nnoremap <leader>eo :vsplit ~/Dropbox/Org<cr>4j
nnoremap <leader>eh :vsplit ~/.hgrc<cr>
nnoremap <leader>eg :vsplit ~/.gitconfig<cr>
nnoremap <leader>ep :vsplit ~/.pentadactylrc<cr>
nnoremap <leader>em :vsplit ~/.mutt/muttrc<cr>
nnoremap <leader>ez :vsplit ~/lib/dotfiles/zsh<cr>4j
nnoremap <leader>ek :vsplit ~/lib/dotfiles/keymando/keymandorc.rb<cr>
nnoremap <leader>et :vsplit ~/.tmux.conf<cr>
nnoremap <leader>es :vsplit ~/.slate<cr>

" }}}
" Searching and movement -------------------------------------------------- {{{

" Use sane regexes.
nnoremap / /\v
vnoremap / /\v

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

set scrolloff=3
set sidescroll=1
set sidescrolloff=10

set virtualedit+=block

noremap <silent> <leader><space> :noh<cr>:call clearmatches()<cr>

runtime macros/matchit.vim
map <tab> %
silent! unmap [%
silent! unmap ]%

" Made D behave
nnoremap D d$

" Don't move on *
" I'd use a function for this but Vim clobbers the last search when you're in
" a function so fuck it, practicality beats purity.
nnoremap <silent> * :let stay_star_view = winsaveview()<cr>*:call winrestview(stay_star_view)<cr>

" Jumping to tags.
"
" Basically, <c-]> jumps to tags (like normal) and <c-\> opens the tag in a new
" split instead.
"
" Both of them will align the destination line to the upper middle part of the
" screen.  Both will pulse the cursor line so you can see where the hell you
" are.  <c-\> will also fold everything in the buffer and then unfold just
" enough for you to see the destination line.
function! JumpToTag()
    execute "normal! \<c-]>mzzvzz15\<c-e>"
    execute "keepjumps normal! `z"
    Pulse
endfunction
function! JumpToTagInSplit()
    execute "normal! \<c-w>v\<c-]>mzzMzvzz15\<c-e>"
    execute "keepjumps normal! `z"
    Pulse
endfunction
nnoremap <c-]> :silent! call JumpToTag()<cr>
nnoremap <c-\> :silent! call JumpToTagInSplit()<cr>

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv

" Same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz
nnoremap <c-o> <c-o>zz

" Easier to type, and I never use the default behavior.
noremap H ^
noremap L $
vnoremap L g_

" Heresy
inoremap <c-a> <esc>I
inoremap <c-e> <esc>A
cnoremap <c-a> <home>
cnoremap <c-e> <end>

" gi already moves to "last place you exited insert mode", so we'll map gI to
" something similar: move to last change
nnoremap gI `.

" Fix linewise visual selection of various text objects
nnoremap VV V
nnoremap Vit vitVkoj
nnoremap Vat vatV
nnoremap Vab vabV
nnoremap VaB vaBV

" Directional Keys {{{

" It's 2013.
noremap j gj
noremap k gk
noremap gj j
noremap gk k

" Easy buffer navigation
noremap <C-h> <C-w>h
noremap <C-j> <C-w>j
noremap <C-k> <C-w>k
noremap <C-l> <C-w>l

noremap <leader>v <C-w>v

" }}}
" Visual Mode */# from Scrooloose {{{

function! s:VSetSearch()
  let temp = @@
  norm! gvy
  let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
  let @@ = temp
endfunction

vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR><c-o>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR><c-o>

" }}}
" List navigation {{{

nnoremap <left>  :cprev<cr>zvzz
nnoremap <right> :cnext<cr>zvzz
nnoremap <up>    :lprev<cr>zvzz
nnoremap <down>  :lnext<cr>zvzz

" }}}

" }}}
" Folding ----------------------------------------------------------------- {{{

set foldlevelstart=0

" Space to toggle folds.
nnoremap <Space> za
vnoremap <Space> za

" Make zO recursively open whatever fold we're in, even if it's partially open.
nnoremap zO zczO

" "Focus" the current line.  Basically:
"
" 1. Close all folds.
" 2. Open just the folds containing the current line.
" 3. Move the line to a little bit (15 lines) above the center of the screen.
" 4. Pulse the cursor line.  My eyes are bad.
"
" This mapping wipes out the z mark, which I never use.
"
" I use :sus for the rare times I want to actually background Vim.
nnoremap <c-z> mzzMzvzz15<c-e>`z:Pulse<cr>

function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . 'â€¦' . repeat(" ",fillcharcount) . foldedlinecount . 'â€¦' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}
" Filetype-specific ------------------------------------------------------- {{{

" Assembly {{{

augroup ft_asm
    au!
    au FileType asm setlocal noexpandtab shiftwidth=8 tabstop=8 softtabstop=8
augroup END

" }}}
" C {{{

augroup ft_c
    au!
    au FileType c setlocal foldmethod=marker foldmarker={,}
augroup END

" }}}
" Clojure {{{

let g:clojure_fold_extra = [
            \ 'defgauge',
            \ 'defmeter',
            \ 'defhistogram',
            \ 'defcounter',
            \ 'deftimer',
            \
            \ 'defdb',
            \ 'defentity',
            \ 'defaspect',
            \ 'add-aspect',
            \ 'defmigration',
            \
            \ 'defsynth',
            \ 'definst',
            \ 'defproject',
            \
            \ 'defroutes',
            \
            \ 'defrec',
            \
            \ 'defparser',
            \
            \ 'defform',
            \ 'defform-',
            \
            \ 'defpage',
            \ 'defsketch'
            \
            \ ]

let g:clojure_highlight_extra_defs = [
            \ 'defparser',
            \ 'deftest',
            \ 'match',
            \
            \ 'defproject',
            \
            \ 'defquery',
            \ 'defqueries',
            \
            \ 'defform',
            \
            \ 'deferror',
            \ 'when-found',
            \ 'when-valid',
            \
            \ 'defroutes'
            \ ]

let g:clojure_highlight_extra_exceptions = [
            \ 'try+',
            \ 'throw+',
            \ ]

augroup ft_clojure
    au!

    au BufNewFile,BufRead *.edn set filetype=clojure
    au BufNewFile,BufRead riemann.config set filetype=clojure

    au FileType clojure silent! call TurnOnClojureFolding()
    au FileType clojure compiler clojure
    au FileType clojure setlocal report=100000

    " Things that should be indented 2-spaced
    au FileType clojure setlocal lispwords+=when-found,defform,when-valid

    au FileType clojure RainbowParenthesesActivate
    au syntax clojure RainbowParenthesesLoadRound
    au syntax clojure RainbowParenthesesLoadSquare
    au syntax clojure RainbowParenthesesLoadBraces

    " Since YCM is hosefucked for Clojure, we'll use omnicompletion on <c-n>
    au FileType clojure inoremap <c-n> <c-x><c-o>

    " And close the omnicomplete preview window after we're done with it.
    au InsertLeave *.clj if pumvisible() == 0|pclose|endif

    " Friendlier Paredit mappings.
    au FileType clojure noremap <buffer> () :<c-u>call PareditWrap("(", ")")<cr>
    au FileType clojure noremap <buffer> )( :<c-u>call PareditSplice()<cr>
    au FileType clojure noremap <buffer> (( :<c-u>call PareditMoveLeft()<cr>
    au FileType clojure noremap <buffer> )) :<c-u>call PareditMoveRight()<cr>
    au FileType clojure noremap <buffer> (j :<c-u>call PareditJoin()<cr>
    au FileType clojure noremap <buffer> (s :<c-u>call PareditSplit()<cr>
    au FileType clojure noremap <buffer> [ :<c-u>call PareditSmartJumpOpening(0)<cr>
    au FileType clojure noremap <buffer> ] :<c-u>call PareditSmartJumpClosing(0)<cr>
    " )))

    " Indent top-level form.
    au FileType clojure nmap <buffer> <localleader>= mz99[(v%='z
    " ])
augroup END

" }}}
" Clojurescript {{{

augroup ft_clojurescript
    au!

    au BufNewFile,BufRead *.cljs set filetype=clojurescript
    au FileType clojurescript call TurnOnClojureFolding()

    " Indent top-level form.
    au FileType clojurescript nmap <buffer> <localleader>= v((((((((((((=%
augroup END

" }}}
" Common Lisp {{{

" function! SendToTmuxStripped(text)
"     call SendToTmux(substitute(a:text, '\v\n*$', '', ''))
" endfunction
function! SetLispWords()
    if exists("g:did_set_lisp_words")
        return
    endif

    let g:did_set_lisp_words = 1

    set lispwords+=switch
    set lispwords+=cswitch
    set lispwords+=eswitch
endfunction

augroup ft_commonlisp
    au!

    au BufNewFile,BufRead *.asd setfiletype lisp

    au FileType lisp call SetLispWords()

    " Set up some basic tslime mappings until I shave the fuckin
    " Fireplace/Common Lisp yak.
    "
    " key  desc                   mnemonic
    " \t - connect tslime         [t]slime
    " \f - send current form      [f]orm
    " \e - send top-level form    [e]val
    " \r - send entire file       [r]eload file
    " \c - send ctrl-l            [c]lear

    " Send the current form to the REPL
    au FileType lisp nnoremap <buffer> <silent> <localleader>f :let lisp_tslime_view = winsaveview()<cr>vab"ry:call SendToTmuxStripped(@r)<cr>:call winrestview(lisp_tslime_view)<cr>

    " Send the current top-level form to the REPL
    au FileType lisp nnoremap <buffer> <silent> <localleader>e :let lisp_tslime_view = winsaveview()<cr>:silent! normal! l<cr>:call PareditFindDefunBck()<cr>vab"ry:call SendToTmuxStripped(@r)<cr>:call winrestview(lisp_tslime_view)<cr>

    " Send the entire buffer to the REPL
    au FileType lisp nnoremap <buffer> <silent> <localleader>r :let lisp_tslime_view = winsaveview()<cr>ggVG"ry:call SendToTmuxStripped(@r)<cr>:call winrestview(lisp_tslime_view)<cr>

    " Clear the REPL
    au FileType lisp nnoremap <buffer> <silent> <localleader>c :call SendToTmuxRaw("")<cr>

    au FileType lisp RainbowParenthesesActivate
    au syntax lisp RainbowParenthesesLoadRound
    au syntax lisp RainbowParenthesesLoadSquare
    au syntax lisp RainbowParenthesesLoadBraces

    au FileType lisp silent! call TurnOnLispFolding()

    au FileType lisp noremap <buffer> () :<c-u>call PareditWrap("(", ")")<cr>
    au FileType lisp noremap <buffer> )( :<c-u>call PareditSplice()<cr>
    au FileType lisp noremap <buffer> (( :<c-u>call PareditMoveLeft()<cr>
    au FileType lisp noremap <buffer> )) :<c-u>call PareditMoveRight()<cr>
    au FileType lisp noremap <buffer> (j :<c-u>call PareditJoin()<cr>
    au FileType lisp noremap <buffer> (s :<c-u>call PareditSplit()<cr>
    au FileType lisp noremap <buffer> )j :<c-u>call PareditJoin()<cr>
    au FileType lisp noremap <buffer> )s :<c-u>call PareditSplit()<cr>
    au FileType lisp noremap <buffer> [[ :<c-u>call PareditSmartJumpOpening(0)<cr>
    au FileType lisp noremap <buffer> ]] :<c-u>call PareditSmartJumpClosing(0)<cr>
    " ))

    " Indent top-level form.
    au FileType lisp nmap <buffer> <localleader>= mz99[(v%='z
    " ])
augroup END

" }}}
" Confluence {{{

augroup ft_c
    au!

    au BufRead,BufNewFile *.confluencewiki setlocal filetype=confluencewiki

    " Wiki pages should be soft-wrapped.
    au FileType confluencewiki setlocal wrap linebreak nolist
augroup END

" }}}
" Cram {{{

let cram_fold=1

augroup ft_cram
    au!

    au BufNewFile,BufRead *.t set filetype=cram
    au Syntax cram setlocal foldlevel=1
    au FileType cram nnoremap <buffer> <localleader>ee :e<cr>
augroup END

" }}}
" CSS and LessCSS {{{

augroup ft_css
    au!

    au BufNewFile,BufRead *.less setlocal filetype=less

    au Filetype less,css setlocal foldmethod=marker
    au Filetype less,css setlocal foldmarker={,}
    au Filetype less,css setlocal omnifunc=csscomplete#CompleteCSS
    au Filetype less,css setlocal iskeyword+=-

    " Use <leader>S to sort properties.  Turns this:
    "
    "     p {
    "         width: 200px;
    "         height: 100px;
    "         background: red;
    "
    "         ...
    "     }
    "
    " into this:

    "     p {
    "         background: red;
    "         height: 100px;
    "         width: 200px;
    "
    "         ...
    "     }
    au BufNewFile,BufRead *.less,*.css nnoremap <buffer> <localleader>S ?{<CR>jV/\v^\s*\}?$<CR>k:sort<CR>:noh<CR>

    " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
    " positioned inside of them AND the following code doesn't get unfolded.
    au BufNewFile,BufRead *.less,*.css inoremap <buffer> {<cr> {}<left><cr><space><space><space><space>.<cr><esc>kA<bs>
augroup END

" }}}
" Django {{{

augroup ft_django
    au!

    au BufNewFile,BufRead urls.py           setlocal nowrap
    au BufNewFile,BufRead urls.py           normal! zR
    au BufNewFile,BufRead dashboard.py      normal! zR
    au BufNewFile,BufRead local_settings.py normal! zR

    au BufNewFile,BufRead admin.py     setlocal filetype=python.django
    au BufNewFile,BufRead urls.py      setlocal filetype=python.django
    au BufNewFile,BufRead models.py    setlocal filetype=python.django
    au BufNewFile,BufRead views.py     setlocal filetype=python.django
    au BufNewFile,BufRead settings.py  setlocal filetype=python.django
    au BufNewFile,BufRead settings.py  setlocal foldmethod=marker
    au BufNewFile,BufRead forms.py     setlocal filetype=python.django
    au BufNewFile,BufRead common_settings.py  setlocal filetype=python.django
    au BufNewFile,BufRead common_settings.py  setlocal foldmethod=marker
augroup END

" }}}
" DTrace {{{

augroup ft_dtrace
    au!

    autocmd BufNewFile,BufRead *.d set filetype=dtrace
augroup END

" }}}
" Firefox {{{

augroup ft_firefox
    au!
    au BufRead,BufNewFile ~/Library/Caches/*.html setlocal buftype=nofile
augroup END

" }}}
" Fish {{{

augroup ft_fish
    au!

    au BufNewFile,BufRead *.fish setlocal filetype=fish

    au FileType fish setlocal foldmethod=marker foldmarker={{{,}}}
augroup END

" }}}
" Haskell {{{

augroup ft_haskell
    au!
    au BufEnter *.hs compiler ghc
augroup END

" }}}
" HTML, Django, Jinja, Dram {{{

let g:html_indent_tags = ['p', 'li']

augroup ft_html
    au!

    au BufNewFile,BufRead *.html setlocal filetype=htmldjango
    au BufNewFile,BufRead *.dram setlocal filetype=htmldjango

    au FileType html,jinja,htmldjango setlocal foldmethod=manual

    " Use <localleader>f to fold the current tag.
    au FileType html,jinja,htmldjango nnoremap <buffer> <localleader>f Vatzf

    " Use <localleader>t to fold the current templatetag.
    au FileType html,jinja,htmldjango nmap <buffer> <localleader>t viikojozf

    " Indent tag
    au FileType html,jinja,htmldjango nnoremap <buffer> <localleader>= Vat=

    " Django tags
    au FileType jinja,htmldjango inoremap <buffer> <c-t> {%<space><space>%}<left><left><left>

    " Django variables
    au FileType jinja,htmldjango inoremap <buffer> <c-b> {{<space><space>}}<left><left><left>
augroup END

" }}}
" Java {{{

augroup ft_java
    au!

    au FileType java setlocal foldmethod=marker
    au FileType java setlocal foldmarker={,}
augroup END

" }}}
" Javascript {{{

augroup ft_javascript
    au!

    au FileType javascript setlocal foldmethod=marker
    au FileType javascript setlocal foldmarker={,}
    au FileType javascript call MakeSpacelessBufferIabbrev('clog', 'console.log();<left><left>')

    " Make {<cr> insert a pair of brackets in such a way that the cursor is correctly
    " positioned inside of them AND the following code doesn't get unfolded.
    au Filetype javascript inoremap <buffer> {<cr> {}<left><cr><space><space><space><space>.<cr><esc>kA<bs>
    " }

    " Prettify a hunk of JSON with <localleader>p
    au FileType javascript nnoremap <buffer> <localleader>p ^vg_:!python -m json.tool<cr>
    au FileType javascript vnoremap <buffer> <localleader>p :!python -m json.tool<cr>
augroup END

" }}}
" Lilypond {{{

augroup ft_lilypond
    au!

    au FileType lilypond setlocal foldmethod=marker foldmarker={,}
augroup END

" }}}
" Mail {{{

augroup ft_mail
    au!

    au Filetype mail setlocal spell
augroup END

" }}}
" Markdown {{{

augroup ft_markdown
    au!

    au BufNewFile,BufRead *.m*down setlocal filetype=markdown foldlevel=1

    " Use <localleader>1/2/3 to add headings.
    au Filetype markdown nnoremap <buffer> <localleader>1 yypVr=:redraw<cr>
    au Filetype markdown nnoremap <buffer> <localleader>2 yypVr-:redraw<cr>
    au Filetype markdown nnoremap <buffer> <localleader>3 mzI###<space><esc>`zllll
    au Filetype markdown nnoremap <buffer> <localleader>4 mzI####<space><esc>`zlllll

    au Filetype markdown nnoremap <buffer> <localleader>p VV:'<,'>!python -m json.tool<cr>
    au Filetype markdown vnoremap <buffer> <localleader>p :!python -m json.tool<cr>
augroup END

" }}}
" Mercurial {{{

augroup ft_mercurial
    au!

    au BufNewFile,BufRead *hg-editor-*.txt setlocal filetype=hgcommit
augroup END

" }}}
" Mutt {{{

augroup ft_muttrc
    au!

    au BufRead,BufNewFile *.muttrc set ft=muttrc

    au FileType muttrc setlocal foldmethod=marker foldmarker={{{,}}}
augroup END

" }}}
" Nand2Tetris HDL {{{

augroup ft_n2thdl
    au!

    au BufNewFile,BufRead *.hdl set filetype=n2thdl
augroup END

" }}}
" Nginx {{{

augroup ft_nginx
    au!

    au BufRead,BufNewFile /etc/nginx/conf/*                      set ft=nginx
    au BufRead,BufNewFile /etc/nginx/sites-available/*           set ft=nginx
    au BufRead,BufNewFile /usr/local/etc/nginx/sites-available/* set ft=nginx
    au BufRead,BufNewFile vhost.nginx                            set ft=nginx

    au FileType nginx setlocal foldmethod=marker foldmarker={,}
augroup END

" }}}
" OrgMode {{{

augroup ft_org
    au!

    au Filetype org nmap <buffer> Q vahjgq
    au Filetype org setlocal nolist
augroup END

" }}}
" Pentadactyl {{{

augroup ft_pentadactyl
    au!
    au BufNewFile,BufRead .pentadactylrc set filetype=pentadactyl
    au BufNewFile,BufRead ~/Library/Caches/TemporaryItems/pentadactyl-*.tmp set nolist wrap linebreak columns=100 colorcolumn=0
augroup END

" }}}
" Postgresql {{{

augroup ft_postgres
    au!

    au BufNewFile,BufRead *.sql set filetype=pgsql
    au BufNewFile,BufRead *.pgsql set filetype=pgsql

    au FileType pgsql set foldmethod=indent
    au FileType pgsql set softtabstop=2 shiftwidth=2
    au FileType pgsql setlocal commentstring=--\ %s comments=:--

    " Send to tmux with localleader e
    au FileType pgsql nnoremap <buffer> <silent> <localleader>e :let psql_tslime_view = winsaveview()<cr>vip"ry:call SendToTmux(@r)<cr>:call winrestview(psql_tslime_view)<cr>

augroup END

    " kill pager with q
    au FileType pgsql nnoremap <buffer> <silent> <localleader>q :call SendToTmuxRaw("q")<cr>

" }}}
" Puppet {{{

augroup ft_puppet
    au!

    au Filetype puppet setlocal foldmethod=marker
    au Filetype puppet setlocal foldmarker={,}
augroup END

" }}}
" Python {{{

augroup ft_python
    au!

    au FileType python setlocal define=^\s*\\(def\\\\|class\\)
    au FileType man nnoremap <buffer> <cr> :q<cr>

    " Jesus tapdancing Christ, built-in Python syntax, you couldn't let me
    " override this in a normal way, could you?
    au FileType python if exists("python_space_error_highlight") | unlet python_space_error_highlight | endif

    au FileType python iabbrev <buffer> afo assert False, "Okay"
augroup END

" }}}
" QuickFix {{{

augroup ft_quickfix
    au!
    au Filetype qf setlocal colorcolumn=0 nolist nocursorline nowrap tw=0
augroup END

" }}}
" ReStructuredText {{{

augroup ft_rest
    au!

    au Filetype rst nnoremap <buffer> <localleader>1 yypVr=:redraw<cr>
    au Filetype rst nnoremap <buffer> <localleader>2 yypVr-:redraw<cr>
    au Filetype rst nnoremap <buffer> <localleader>3 yypVr~:redraw<cr>
    au Filetype rst nnoremap <buffer> <localleader>4 yypVr`:redraw<cr>
augroup END

" }}}
" Riemann Config Files {{{

augroup ft_riemann
    au!

    au BufNewFile,BufRead riemann.config set filetype=clojure
    au BufNewFile,BufRead riemann.config nnoremap <buffer> <localleader>= mzgg=G`z
augroup END

" }}}
" Rubby {{{

augroup ft_ruby
    au!
    au Filetype ruby setlocal foldmethod=syntax
    au BufRead,BufNewFile Capfile setlocal filetype=ruby
augroup END

" }}}
" Scala {{{

augroup ft_scala
    au!
    au Filetype scala setlocal foldmethod=marker foldmarker={,}
    au Filetype scala setlocal textwidth=100
    au Filetype scala compiler maven
    au Filetype scala let b:dispatch = 'mvn -B package install'
    au Filetype scala nnoremap <buffer> <localleader>s mz:%!sort-scala-imports<cr>`z
    au Filetype scala nnoremap <buffer> M :call scaladoc#Search(expand("<cword>"))<cr>
    au Filetype scala vnoremap <buffer> M "ry:call scaladoc#Search(@r)<cr>
    au Filetype scala nmap <buffer> <localleader>( ysiwbi
    au Filetype scala nmap <buffer> <localleader>[ ysiwri
    ")]
augroup END

" }}}
" Standard In {{{

augroup ft_stdin
    au!

    " Treat buffers from stdin (e.g.: echo foo | vim -) as scratch.
    au StdinReadPost * :set buftype=nofile
augroup END

" }}}
" stevelosh.com Blog Entries {{{

augroup ft_steveloshcom
    au!
    au BufRead,BufNewFile */stevelosh/content/blog/20*/*/*.html set ft=markdown spell
    au BufRead,BufNewFile */stevelosh/content/projects/*.html set ft=markdown spell
augroup END

" }}}
" TimL {{{

" let g:timl_fold_extra = [
"             \ 'defgauge',
"             \ 'defmeter',
"             \ 'defhistogram',
"             \ 'defcounter',
"             \ 'deftimer'
"             \ ]

" let g:timl_highlight_extra_defs = [
"             \ 'defparser',
"             \ 'deftest',
"             \ 'match',
"             \
"             \ 'defroutes'
"             \ ]


augroup ft_timl
    au!

    au FileType timl silent! call TurnOnClojureFolding()

    " Things that should be indented 2-spaced
    " au FileType clojure setlocal lispwords+=when-found,defform,when-valid

    au FileType timl RainbowParenthesesActivate
    au syntax timl RainbowParenthesesLoadRound
    au syntax timl RainbowParenthesesLoadSquare
    au syntax timl RainbowParenthesesLoadBraces

    " Friendlier Paredit mappings.
    au FileType timl noremap <buffer> () :<c-u>call PareditWrap("(", ")")<cr>
    au FileType timl noremap <buffer> )( :<c-u>call PareditSplice()<cr>
    au FileType timl noremap <buffer> (( :<c-u>call PareditMoveLeft()<cr>
    au FileType timl noremap <buffer> )) :<c-u>call PareditMoveRight()<cr>
    au FileType timl noremap <buffer> (j :<c-u>call PareditJoin()<cr>
    au FileType timl noremap <buffer> (s :<c-u>call PareditSplit()<cr>
    au FileType timl noremap <buffer> [ :<c-u>call PareditSmartJumpOpening(0)<cr>
    au FileType timl noremap <buffer> ] :<c-u>call PareditSmartJumpClosing(0)<cr>
    " )))

    au FileType timl call PareditInitBuffer()

    " Indent top-level form.
    au FileType timl nmap <buffer> <localleader>= mz99[(v%='z
    " ])
augroup END

" }}}
" Vagrant {{{

augroup ft_vagrant
    au!
    au BufRead,BufNewFile Vagrantfile set ft=ruby
augroup END

" }}}
" Vim {{{

augroup ft_vim
    au!

    au FileType vim setlocal foldmethod=marker
    au FileType help setlocal textwidth=78
    au BufWinEnter *.txt if &ft == 'help' | wincmd L | endif
augroup END

" }}}
" YAML {{{

augroup ft_yaml
    au!

    au FileType yaml set shiftwidth=2
augroup END

" }}}
" XML {{{

augroup ft_xml
    au!

    au FileType xml setlocal foldmethod=manual

    " Use <localleader>f to fold the current tag.
    au FileType xml nnoremap <buffer> <localleader>f Vatzf

    " Indent tag
    au FileType xml nnoremap <buffer> <localleader>= Vat=
augroup END

" }}}

" }}}
" Plugin settings --------------------------------------------------------- {{{

" Ack {{{

nnoremap <leader>a :Ack!<space>
let g:ackprg = 'ag --smart-case --nogroup --nocolor --column'

" }}}
" Autoclose {{{

nmap <Leader>x <Plug>ToggleAutoCloseMappings

" }}}
" Clam {{{

nnoremap ! :Clam<space>
vnoremap ! :ClamVisual<space>
let g:clam_autoreturn = 1
let g:clam_debug = 1

" }}}
" Commentary {{{

nmap <leader>c <Plug>CommentaryLine
xmap <leader>c <Plug>Commentary

augroup plugin_commentary
    au!
    au FileType htmldjango setlocal commentstring={#\ %s\ #}
    au FileType clojurescript setlocal commentstring=;\ %s
    au FileType lisp setlocal commentstring=;\ %s
    au FileType puppet setlocal commentstring=#\ %s
    au FileType fish setlocal commentstring=#\ %s
augroup END

" }}}
" Ctrl-P {{{

let g:ctrlp_dont_split = 'NERD_tree_2'
let g:ctrlp_jump_to_buffer = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_match_window_reversed = 1
let g:ctrlp_split_window = 0
let g:ctrlp_max_height = 20
let g:ctrlp_extensions = ['tag']

let g:ctrlp_map = '<leader>,'
nnoremap <leader>. :CtrlPTag<cr>

let g:ctrlp_prompt_mappings = {
\ 'PrtSelectMove("j")':   ['<c-j>', '<down>', '<s-tab>'],
\ 'PrtSelectMove("k")':   ['<c-k>', '<up>', '<tab>'],
\ 'PrtHistory(-1)':       ['<c-n>'],
\ 'PrtHistory(1)':        ['<c-p>'],
\ 'ToggleFocus()':        ['<c-tab>'],
\ }

let ctrlp_filter_greps = "".
    \ "egrep -iv '\\.(" .
    \ "jar|class|swp|swo|log|so|o|pyc|jpe?g|png|gif|mo|po" .
    \ ")$' | " .
    \ "egrep -v '^(\\./)?(" .
    \ "deploy/|lib/|classes/|libs/|deploy/vendor/|.git/|.hg/|.svn/|.*migrations/|docs/build/" .
    \ ")'"

let my_ctrlp_user_command = "" .
    \ "find %s '(' -type f -or -type l ')' -maxdepth 15 -not -path '*/\\.*/*' | " .
    \ ctrlp_filter_greps

let my_ctrlp_git_command = "" .
    \ "cd %s && git ls-files --exclude-standard -co | " .
    \ ctrlp_filter_greps

let my_ctrlp_ffind_command = "ffind --semi-restricted --dir %s --type e -B -f"

let g:ctrlp_user_command = ['.git/', my_ctrlp_ffind_command, my_ctrlp_ffind_command]

" }}}
" DelimitMate {{{

let delimitMate_excluded_ft = "clojure,lisp"

" }}}
" Dispatch {{{

nnoremap <leader>d :Dispatch<cr>
nnoremap <leader>m :Dispatch<cr>

" }}}
" Fugitive {{{

let g:fugitive_github_domains = ['github.banksimple.com']

nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>ga :Gadd<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>gco :Gcheckout<cr>
nnoremap <leader>gci :Gcommit<cr>
nnoremap <leader>gm :Gmove<cr>
nnoremap <leader>gr :Gremove<cr>
nnoremap <leader>gl :Shell git gl -18<cr>:wincmd \|<cr>

augroup ft_fugitive
    au!

    au BufNewFile,BufRead .git/index setlocal nolist
augroup END

" "Hub"
vnoremap <leader>H :Gbrowse<cr>

" }}}
" GnuPG {{{

let g:GPGPreferArmor = 1

" }}}
" Gundo {{{

nnoremap <F5> :GundoToggle<CR>

let g:gundo_debug = 1
let g:gundo_preview_bottom = 1
let g:gundo_tree_statusline = "Gundo"
let g:gundo_preview_statusline = "Gundo Preview"

" }}}
" Haskellmode {{{

let g:haddock_browser = "open"
let g:haddock_browser_callformat = "%s %s"
let g:ghc = "/usr/local/bin/ghc"

" }}}
" HTML5 {{{

let g:event_handler_attributes_complete = 0
let g:rdfa_attributes_complete = 0
let g:microdata_attributes_complete = 0
let g:atia_attributes_complete = 0

" }}}
" Linediff {{{

vnoremap <leader>l :Linediff<cr>
nnoremap <leader>L :LinediffReset<cr>

" }}}
" Makegreen {{{

nnoremap \| :call MakeGreen('')<cr>

" }}}
" Maven {{{

let g:maven_disable_mappings = 1

" }}}
" NERD Tree {{{

noremap  <F2> :NERDTreeToggle<cr>
inoremap <F2> <esc>:NERDTreeToggle<cr>

augroup ps_nerdtree
    au!

    au Filetype nerdtree setlocal nolist
    au Filetype nerdtree nnoremap <buffer> H :vertical resize -10<cr>
    au Filetype nerdtree nnoremap <buffer> L :vertical resize +10<cr>
    " au Filetype nerdtree nnoremap <buffer> K :q<cr>
augroup END

let NERDTreeHighlightCursorline = 1
let NERDTreeIgnore = ['.vim$', '\~$', '.*\.pyc$', 'pip-log\.txt$', 'whoosh_index',
                    \ 'xapian_index', '.*.pid', 'monitor.py', '.*-fixtures-.*.json',
                    \ '.*\.o$', 'db.db', 'tags.bak', '.*\.pdf$', '.*\.mid$',
                    \ '.*\.midi$']

let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
let NERDChristmasTree = 1
let NERDTreeChDirMode = 2
let NERDTreeMapJumpFirstChild = 'gK'

" }}}
" OrgMode {{{

let g:org_heading_shade_leading_stars = 0
" let g:org_plugins = ['ShowHide', '|', 'Navigator', 'EditStructure', '|', 'Todo', 'Date', 'Misc']

" let g:org_todo_keywords = ['TODO', '|', 'DONE']

" let g:org_debug = 1

" }}}
" Paredit {{{

let g:paredit_smartjump = 1
let g:paredit_shortmaps = 0
let g:paredit_electric_return = 1

" }}}
" Powerline {{{

let g:Powerline_symbols = 'fancy'
let g:Powerline_cache_enabled = 1
let g:Powerline_colorscheme = 'badwolf'

" }}}
" Python-Mode {{{

let g:pymode_doc = 1
let g:pymode_doc_key = 'M'
let g:pydoc = 'pydoc'
let g:pymode_syntax = 1
let g:pymode_syntax_all = 0
let g:pymode_syntax_builtin_objs = 1
let g:pymode_syntax_print_as_function = 0
let g:pymode_syntax_space_errors = 0
let g:pymode_run = 0
let g:pymode_lint = 0
let g:pymode_breakpoint = 0
let g:pymode_utils_whitespaces = 0
let g:pymode_virtualenv = 0
let g:pymode_folding = 0

let g:pymode_options_indent = 0
let g:pymode_options_fold = 0
let g:pymode_options_other = 0
let g:pymode_options = 0

let g:pymode_rope = 1
let g:pymode_rope_global_prefix = "<localleader>R"
let g:pymode_rope_local_prefix = "<localleader>r"
let g:pymode_rope_auto_project = 1
let g:pymode_rope_enable_autoimport = 0
let g:pymode_rope_autoimport_generate = 1
let g:pymode_rope_autoimport_underlineds = 0
let g:pymode_rope_codeassist_maxfixes = 10
let g:pymode_rope_sorted_completions = 1
let g:pymode_rope_extended_complete = 1
let g:pymode_rope_autoimport_modules = ["os", "shutil", "datetime"]
let g:pymode_rope_confirm_saving = 1
let g:pymode_rope_vim_completion = 1
let g:pymode_rope_guess_project = 1
let g:pymode_rope_goto_def_newwin = 0
let g:pymode_rope_always_show_complete_menu = 0

" }}}
" Scratch {{{

command! ScratchToggle call ScratchToggle()

function! ScratchToggle()
    if exists("w:is_scratch_window")
        unlet w:is_scratch_window
        exec "q"
    else
        exec "normal! :Sscratch\<cr>\<C-W>L"
        let w:is_scratch_window = 1
    endif
endfunction

nnoremap <silent> <leader><tab> :ScratchToggle<cr>

" }}}
" Secure Modelines {{{

let g:secure_modelines_allowed_items = [
            \ "textwidth",   "tw",
            \ "foldmethod",  "fdm",
            \ "foldnextmax",  "fdn",
            \ ]

" }}}
" Sparkup {{{

let g:sparkupNextMapping = '<c-s>'

"}}}
" Supertab {{{

let g:SuperTabDefaultCompletionType = "<c-n>"
let g:SuperTabLongestHighlight = 1
let g:SuperTabCrMapping = 1

"}}}
" Syntastic {{{

let g:syntastic_enable_signs = 1
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_auto_jump = 0
let g:syntastic_java_checker = 'javac'
let g:syntastic_mode_map = {
            \ "mode": "active",
            \ "active_filetypes": [],
            \ "passive_filetypes": ['java', 'html', 'rst']
            \ }
let g:syntastic_stl_format = '[%E{%e Errors}%B{, }%W{%w Warnings}]'
let g:syntastic_jsl_conf = '$HOME/.vim/jsl.conf'
let g:syntastic_scala_checkers = ['fsc']

nnoremap <leader>C :SyntasticCheck<cr>

" }}}
" Splice {{{

let g:splice_prefix = "-"

let g:splice_initial_mode = "grid"

let g:splice_initial_layout_grid = 0
let g:splice_initial_layout_loupe = 0
let g:splice_initial_layout_compare = 0
let g:splice_initial_layout_path = 0

let g:splice_initial_diff_grid = 1
let g:splice_initial_diff_loupe = 0
let g:splice_initial_diff_compare = 1
let g:splice_initial_diff_path = 0

let g:splice_initial_scrollbind_grid = 0
let g:splice_initial_scrollbind_loupe = 0
let g:splice_initial_scrollbind_compare = 0
let g:splice_initial_scrollbind_path = 0

let g:splice_wrap = "nowrap"

" }}}
" tslime {{{

let g:tslime_ensure_trailing_newlines = 1
let g:tslime_normal_mapping = '<localleader>T'
let g:tslime_visual_mapping = '<localleader>t'
let g:tslime_vars_mapping = '<localleader>t'

" }}}
" YankRing {{{

function! YRRunAfterMaps()
    " Make Y yank to end of line.
    nnoremap Y :<C-U>YRYankCount 'y$'<CR>

    " Fix L and H in operator-pending mode, so yH and such works.
    omap <expr> L YRMapsExpression("", "$")
    omap <expr> H YRMapsExpression("", "^")

    " Don't clobber the yank register when pasting over text in visual mode.
    vnoremap p :<c-u>YRPaste 'p', 'v'<cr>gv:YRYankRange 'v'<cr>
endfunction

" }}}

" }}}
" Text objects ------------------------------------------------------------ {{{

" Shortcut for [] {{{

onoremap ir i[
onoremap ar a[
vnoremap ir i[
vnoremap ar a[

" }}}
" Next and Last {{{
"
" Motion for "next/last object".  "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type, last acts on the previous
" object of the given type.  These don't necessarily have to be in the current
" line.
"
" Currently works for (, [, {, and their shortcuts b, r, B. 
"
" Next kind of works for ' and " as long as there are no escaped versions of
" them in the string (TODO: fix that).  Last is currently broken for quotes
" (TODO: fix that).
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din'  -> delete in next single quotes                foo = bar('spam')
"                                                      C
"                                                      foo = bar('')
"                                                                C
"
" canb  -> change around next parens                   foo = bar('spam')
"                                                      C
"                                                      foo = bar
"                                                               C
"
" vin"  -> select inside next double quotes            print "hello ", name
"                                                       C
"                                                      print "hello ", name
"                                                             VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>


function! s:NextTextObject(motion, dir)
    let c = nr2char(getchar())
    let d = ''

    if c ==# "b" || c ==# "(" || c ==# ")"
        let c = "("
    elseif c ==# "B" || c ==# "{" || c ==# "}"
        let c = "{"
    elseif c ==# "r" || c ==# "[" || c ==# "]"
        let c = "["
    elseif c ==# "'"
        let c = "'"
    elseif c ==# '"'
        let c = '"'
    else
        return
    endif

    " Find the next opening-whatever.
    execute "normal! " . a:dir . c . "\<cr>"

    if a:motion ==# 'a'
        " If we're doing an 'around' method, we just need to select around it
        " and we can bail out to Vim.
        execute "normal! va" . c
    else
        " Otherwise we're looking at an 'inside' motion.  Unfortunately these
        " get tricky when you're dealing with an empty set of delimiters because
        " Vim does the wrong thing when you say vi(.

        let open = ''
        let close = ''

        if c ==# "(" 
            let open = "("
            let close = ")"
        elseif c ==# "{"
            let open = "{"
            let close = "}"
        elseif c ==# "["
            let open = "\\["
            let close = "\\]"
        elseif c ==# "'"
            let open = "'"
            let close = "'"
        elseif c ==# '"'
            let open = '"'
            let close = '"'
        endif

        " We'll start at the current delimiter.
        let start_pos = getpos('.')
        let start_l = start_pos[1]
        let start_c = start_pos[2]

        " Then we'll find it's matching end delimiter.
        if c ==# "'" || c ==# '"'
            " searchpairpos() doesn't work for quotes, because fuck me.
            let end_pos = searchpos(open)
        else
            let end_pos = searchpairpos(open, '', close)
        endif

        let end_l = end_pos[0]
        let end_c = end_pos[1]

        call setpos('.', start_pos)

        if start_l == end_l && start_c == (end_c - 1)
            " We're in an empty set of delimiters.  We'll append an "x"
            " character and select that so most Vim commands will do something
            " sane.  v is gonna be weird, and so is y.  Oh well.
            execute "normal! ax\<esc>\<left>"
            execute "normal! vi" . c
        elseif start_l == end_l && start_c == (end_c - 2)
            " We're on a set of delimiters that contain a single, non-newline
            " character.  We can just select that and we're done.
            execute "normal! vi" . c
        else
            " Otherwise these delimiters contain something.  But we're still not
            " sure Vim's gonna work, because if they contain nothing but
            " newlines Vim still does the wrong thing.  So we'll manually select
            " the guts ourselves.
            let whichwrap = &whichwrap
            set whichwrap+=h,l

            execute "normal! va" . c . "hol"

            let &whichwrap = whichwrap
        endif
    endif
endfunction

" }}}
" Numbers {{{

" Motion for numbers.  Great for CSS.  Lets you do things like this:
"
" margin-top: 200px; -> daN -> margin-top: px;
"              ^                          ^
" TODO: Handle floats.

onoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
xnoremap N :<c-u>call <SID>NumberTextObject(0)<cr>
onoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap aN :<c-u>call <SID>NumberTextObject(1)<cr>
onoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>
xnoremap iN :<c-u>call <SID>NumberTextObject(1)<cr>

function! s:NumberTextObject(whole)
    let num = '\v[0-9]'

    " If the current char isn't a number, walk forward.
    while getline('.')[col('.') - 1] !~# num
        normal! l
    endwhile

    " Now that we're on a number, start selecting it.
    normal! v

    " If the char after the cursor is a number, select it.
    while getline('.')[col('.')] =~# num
        normal! l
    endwhile

    " If we want an entire word, flip the select point and walk.
    if a:whole
        normal! o

        while col('.') > 1 && getline('.')[col('.') - 2] =~# num
            normal! h
        endwhile
    endif
endfunction

" }}}

" }}}
" Mini-plugins ------------------------------------------------------------ {{{
" Stuff that should probably be broken out into plugins, but hasn't proved to be
" worth the time to do so just yet.

" Synstack {{{

" Show the stack of syntax hilighting classes affecting whatever is under the
" cursor.
function! SynStack()
  echo join(map(synstack(line('.'), col('.')), 'synIDattr(v:val, "name")'), " > ")
endfunc

nnoremap <F7> :call SynStack()<CR>

" }}}
" Diffwhite Toggle {{{

set diffopt-=iwhite
let g:diffwhitespaceon = 0
function! ToggleDiffWhitespace()
    if g:diffwhitespaceon
        set diffopt-=iwhite
        let g:diffwhitespaceon = 0
    else
        set diffopt+=iwhite
        let g:diffwhitespaceon = 1
    endif
    diffupdate
endfunc

" TODO: Figure out the diffexpr shit necessary to make this buffer-local.
" nnoremap <leader>W :call ToggleDiffWhitespace()<CR>

" }}}
" Error Toggles {{{

command! ErrorsToggle call ErrorsToggle()
function! ErrorsToggle() " {{{
  if exists("w:is_error_window")
    unlet w:is_error_window
    exec "q"
  else
    exec "Errors"
    lopen
    let w:is_error_window = 1
  endif
endfunction " }}}

command! -bang -nargs=? QFixToggle call QFixToggle(<bang>0)
function! QFixToggle(forced) " {{{
  if exists("g:qfix_win") && a:forced == 0
    cclose
    unlet g:qfix_win
  else
    copen 10
    let g:qfix_win = bufnr("$")
  endif
endfunction " }}}

nmap <silent> <f3> :ErrorsToggle<cr>
nmap <silent> <f4> :QFixToggle<cr>

" }}}
" Nyan! {{{

function! NyanMe() " {{{
    hi NyanFur             guifg=#BBBBBB
    hi NyanPoptartEdge     guifg=#ffd0ac
    hi NyanPoptartFrosting guifg=#fd3699 guibg=#fe98ff
    hi NyanRainbow1        guifg=#6831f8
    hi NyanRainbow2        guifg=#0099fc
    hi NyanRainbow3        guifg=#3cfa04
    hi NyanRainbow4        guifg=#fdfe00
    hi NyanRainbow5        guifg=#fc9d00
    hi NyanRainbow6        guifg=#fe0000


    echohl NyanRainbow1
    echon "â‰ˆ"
    echohl NyanRainbow2
    echon "â‰‹"
    echohl NyanRainbow3
    echon "â‰ˆ"
    echohl NyanRainbow4
    echon "â‰‹"
    echohl NyanRainbow5
    echon "â‰ˆ"
    echohl NyanRainbow6
    echon "â‰‹"
    echohl NyanRainbow1
    echon "â‰ˆ"
    echohl NyanRainbow2
    echon "â‰‹"
    echohl NyanRainbow3
    echon "â‰ˆ"
    echohl NyanRainbow4
    echon "â‰‹"
    echohl NyanRainbow5
    echon "â‰ˆ"
    echohl NyanRainbow6
    echon "â‰‹"
    echohl None
    echo ""

    echohl NyanRainbow1
    echon "â‰ˆ"
    echohl NyanRainbow2
    echon "â‰‹"
    echohl NyanRainbow3
    echon "â‰ˆ"
    echohl NyanRainbow4
    echon "â‰‹"
    echohl NyanRainbow5
    echon "â‰ˆ"
    echohl NyanRainbow6
    echon "â‰‹"
    echohl NyanRainbow1
    echon "â‰ˆ"
    echohl NyanRainbow2
    echon "â‰‹"
    echohl NyanRainbow3
    echon "â‰ˆ"
    echohl NyanRainbow4
    echon "â‰‹"
    echohl NyanRainbow5
    echon "â‰ˆ"
    echohl NyanRainbow6
    echon "â‰‹"
    echohl NyanFur
    echon "â•°"
    echohl NyanPoptartEdge
    echon "âŸ¨"
    echohl NyanPoptartFrosting
    echon "â£®â£¯â¡¿"
    echohl NyanPoptartEdge
    echon "âŸ©"
    echohl NyanFur
    echon "â©¾^Ï‰^â©½"
    echohl None
    echo ""

    echohl NyanRainbow1
    echon "â‰ˆ"
    echohl NyanRainbow2
    echon "â‰‹"
    echohl NyanRainbow3
    echon "â‰ˆ"
    echohl NyanRainbow4
    echon "â‰‹"
    echohl NyanRainbow5
    echon "â‰ˆ"
    echohl NyanRainbow6
    echon "â‰‹"
    echohl NyanRainbow1
    echon "â‰ˆ"
    echohl NyanRainbow2
    echon "â‰‹"
    echohl NyanRainbow3
    echon "â‰ˆ"
    echohl NyanRainbow4
    echon "â‰‹"
    echohl NyanRainbow5
    echon "â‰ˆ"
    echohl NyanRainbow6
    echon "â‰‹"
    echohl None
    echon " "
    echohl NyanFur
    echon "â€   â€Ÿ"
    echohl None

    sleep 1
    redraw
    echo " "
    echo " "
    echo "Noms?"
    redraw
endfunction " }}}
command! NyanMe call NyanMe()

" }}}
" Hg {{{

function! s:HgDiff() " {{{
    diffthis

    let fn = expand('%:p')
    let ft = &ft

    wincmd v
    edit __hgdiff_orig__

    setlocal buftype=nofile

    normal ggdG
    execute "silent r!hg cat --rev . " . fn
    normal ggdd

    execute "setlocal ft=" . ft

    diffthis
    diffupdate
endfunction " }}}
command! -nargs=0 HgDiff call s:HgDiff()
nnoremap <leader>Hd :HgDiff<cr>

function! s:HgBlame() " {{{
    let fn = expand('%:p')

    wincmd v
    wincmd h
    edit __hgblame__
    vertical resize 28

    setlocal scrollbind winfixwidth nolist nowrap nonumber buftype=nofile ft=none

    normal ggdG
    execute "silent r!hg blame -undq " . fn
    normal ggdd
    execute ':%s/\v:.*$//'

    wincmd l
    setlocal scrollbind
    syncbind
endfunction " }}}
command! -nargs=0 HgBlame call s:HgBlame()
nnoremap <leader>Hb :HgBlame<cr>

" }}}
" Ack motions {{{

" Motions to Ack for things.  Works with pretty much everything, including:
"
"   w, W, e, E, b, B, t*, f*, i*, a*, and custom text objects
"
" Awesome.
"
" Note: If the text covered by a motion contains a newline it won't work.  Ack
" searches line-by-line.

nnoremap <silent> <leader>A :set opfunc=<SID>AckMotion<CR>g@
xnoremap <silent> <leader>A :<C-U>call <SID>AckMotion(visualmode())<CR>

nnoremap <bs> :Ack! '\b<c-r><c-w>\b'<cr>
xnoremap <silent> <bs> :<C-U>call <SID>AckMotion(visualmode())<CR>

function! s:CopyMotionForType(type)
    if a:type ==# 'v'
        silent execute "normal! `<" . a:type . "`>y"
    elseif a:type ==# 'char'
        silent execute "normal! `[v`]y"
    endif
endfunction

function! s:AckMotion(type) abort
    let reg_save = @@

    call s:CopyMotionForType(a:type)

    execute "normal! :Ack! --literal " . shellescape(@@) . "\<cr>"

    let @@ = reg_save
endfunction

" }}}
" Indent Guides {{{

let g:indentguides_state = 0
function! IndentGuides() " {{{
    if g:indentguides_state
        let g:indentguides_state = 0
        2match None
    else
        let g:indentguides_state = 1
        execute '2match IndentGuides /\%(\_^\s*\)\@<=\%(\%'.(0*&sw+1).'v\|\%'.(1*&sw+1).'v\|\%'.(2*&sw+1).'v\|\%'.(3*&sw+1).'v\|\%'.(4*&sw+1).'v\|\%'.(5*&sw+1).'v\|\%'.(6*&sw+1).'v\|\%'.(7*&sw+1).'v\)\s/'
    endif
endfunction " }}}
hi def IndentGuides guibg=#303030 ctermbg=234
nnoremap <leader>I :call IndentGuides()<cr>

" }}}
" Block Colors {{{

let g:blockcolor_state = 0
function! BlockColor() " {{{
    if g:blockcolor_state
        let g:blockcolor_state = 0
        call matchdelete(77881)
        call matchdelete(77882)
        call matchdelete(77883)
        call matchdelete(77884)
        call matchdelete(77885)
        call matchdelete(77886)
    else
        let g:blockcolor_state = 1
        call matchadd("BlockColor1", '^ \{4}.*', 1, 77881)
        call matchadd("BlockColor2", '^ \{8}.*', 2, 77882)
        call matchadd("BlockColor3", '^ \{12}.*', 3, 77883)
        call matchadd("BlockColor4", '^ \{16}.*', 4, 77884)
        call matchadd("BlockColor5", '^ \{20}.*', 5, 77885)
        call matchadd("BlockColor6", '^ \{24}.*', 6, 77886)
    endif
endfunction " }}}
" Default highlights {{{
hi def BlockColor1 guibg=#222222 ctermbg=234
hi def BlockColor2 guibg=#2a2a2a ctermbg=235
hi def BlockColor3 guibg=#353535 ctermbg=236
hi def BlockColor4 guibg=#3d3d3d ctermbg=237
hi def BlockColor5 guibg=#444444 ctermbg=238
hi def BlockColor6 guibg=#4a4a4a ctermbg=239
" }}}
nnoremap <leader>B :call BlockColor()<cr>

" }}}
" Pulse Line {{{

function! s:Pulse() " {{{
    redir => old_hi
        silent execute 'hi CursorLine'
    redir END
    let old_hi = split(old_hi, '\n')[0]
    let old_hi = substitute(old_hi, 'xxx', '', '')

    let steps = 8
    let width = 1
    let start = width
    let end = steps * width
    let color = 233

    for i in range(start, end, width)
        execute "hi CursorLine ctermbg=" . (color + i)
        redraw
        sleep 6m
    endfor
    for i in range(end, start, -1 * width)
        execute "hi CursorLine ctermbg=" . (color + i)
        redraw
        sleep 6m
    endfor

    execute 'hi ' . old_hi
endfunction " }}}
command! -nargs=0 Pulse call s:Pulse()

" }}}
" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd("InterestingWord" . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Mappings {{{

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" }}}
" Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}

" }}}
" MarkChanged {{{

sign define line_changed text=+ texthl=DiffAdded

function! MarkChanged(s, e)
    for i in range(a:s, a:e)
        exe ":sign place " . i . " line=" . i . " name=line_changed file=" . expand("%:p")
    endfor
endfunction

function! MarkUnchanged(s, e)
    for i in range(a:s, a:e)
        call cursor(i, 0)
        silent! sign unplace
    endfor
endfunction

command! -range MarkChanged call MarkChanged(<line1>, <line2>)
command! -range MarkUnchanged call MarkUnchanged(<line1>, <line2>)

" nnoremap <leader>m :MarkChanged<cr>
" vnoremap <leader>m :MarkChanged<cr>
" nnoremap <leader>M :MarkUnchanged<cr>
" vnoremap <leader>M :MarkUnchanged<cr>

" }}}
" MS to UTC {{{

function! MS2UTC(ms)
    let seconds = strpart(a:ms, 0, strlen(a:ms) - 3)
    return substitute(system("date -ur " . seconds), "\n\n*", "", "")
endfunction

function! MS2UTCWord()
    return MS2UTC(expand("<cword>"))
endfunction

nnoremap <leader>U :echo MS2UTCWord()<cr>

" }}}

" }}}
" Environments (GUI/Console) ---------------------------------------------- {{{

if has('gui_running')
    " GUI Vim

    set guifont=Menlo\ Regular\ for\ Powerline:h12

    " Remove all the UI cruft
    set go-=T
    set go-=l
    set go-=L
    set go-=r
    set go-=R

    highlight SpellBad term=underline gui=undercurl guisp=Orange

    " Different cursors for different modes.
    set guicursor=n-c:block-Cursor-blinkon0
    set guicursor+=v:block-vCursor-blinkon0
    set guicursor+=i-ci:ver20-iCursor

    if has("gui_macvim")
        " Full screen means FULL screen
        set fuoptions=maxvert,maxhorz

        " Use the normal HIG movements, except for M-Up/Down
        let macvim_skip_cmd_opt_movement = 1
        no   <D-Left>       <Home>
        no!  <D-Left>       <Home>
        no   <M-Left>       <C-Left>
        no!  <M-Left>       <C-Left>

        no   <D-Right>      <End>
        no!  <D-Right>      <End>
        no   <M-Right>      <C-Right>
        no!  <M-Right>      <C-Right>

        no   <D-Up>         <C-Home>
        ino  <D-Up>         <C-Home>
        imap <M-Up>         <C-o>{

        no   <D-Down>       <C-End>
        ino  <D-Down>       <C-End>
        imap <M-Down>       <C-o>}

        imap <M-BS>         <C-w>
        inoremap <D-BS>     <esc>my0c`y
    else
        " Non-MacVim GUI, like Gvim
    end
else
    " Console Vim
    " For me, this means iTerm2, possibly through tmux

    " Mouse support
    set mouse=a
endif

" }}}
