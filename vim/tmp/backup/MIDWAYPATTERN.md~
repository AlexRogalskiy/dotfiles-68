TESTING BUNKAI: the Midway Integration Test Pattern
===================================================

When building out an AngularJS Application, it is often useful to begin
outside-in with an integration test. A number of excellent tools exist
for end-to-end testing, notably Protractor and Selenium. However, those
tools are relatively slow, and in my view, somewhat cumbersome to use.

An intermediate mode of testing applications up to application
boundaries is the Midway pattern, which is to create a dynamic DOM
fragment in memory, load it up in Angular, and test its response to
various stimuli. One advantage of the Midway pattern when used with
Karama is that no server is actually necessary, just the browser itself.
This is facilitated by:

-   Using the Angular template cache to read templates without a server,
    fed by Karma's html2js preprocessors.

-   Using the Angular `$compile` and `$rootScope` services, injected by
    means of the Angular mock library to create a dynamic DOM fragment.

-   Simulating stimulus such as user typing and clicks by way of various
    trigger operations.

The `$templateCache`.
---------------------

Karma can be programmed to preprocess all html files into angular
modules, with names corresponding to the filename. By executing the
`module('foo.html')` command to load that module, the Angular
`$templateCache` service is filled with the corresponding text. For
example, we can load the 'index.html' file in the root directory with
into the element property of a `PAGE OBJECT` with the following code:

```javascript
module('index.html');
inject(function($templateCache){
  page.element = $($templateCache.get('index.html'));
})
```

The text might appear in a `beforeEach` block for all tests in a
corresponding `describe` scope, or in a function called at the beginning
of a test. Commonly, a complex page object may be initialized with a
function named something like:
`GIVEN_SmushyPageFor(state, information)`) which is placed at the outset
of each integration feature scenario. The complexity of the Kata might
dictate how this pattern is used.

The Midway Dynamic DOM Fragment.
--------------------------------

Angular permits us to compile, link and initialize a dynamic DOM
fragment. The general pattern is:

```javascript
inject(function($compile, $rootScope){
  page.element = $compile(... code ...)($rootScope)
  $rootScope.$digest();
});

```

### Simple Midway Object Compiling index.html.

One or more modules may need to be set up (including potential
`$provide`rs), to instantiate a proper injector for the fragment. That
said, the fragment should respond to appropriate stimulus, direct or
simulated, and the resulting date can then be "scraped" for purposes of
testing. The following combines this pattern with the foregoing, to
compile and instantiate an "index.html" file in a simple application,
with an application module 'app'.


```javascript
beforeEach(function(){
  module('app', 'index.html')
  inject(function($templateCache, $compile, $rootScope){
    page.element = $compile($templateCache.get('index.html'))($rootScope);
    $rootScope.$digest();
  });
});

```

### Mideway Object Inserting State Using a `$provide`r.

If the application needs to have some test-specific state information
injected into a service, for example, that might be accomplished with
something along the lines of:

```javascript
function GIVEN_GnarlyPageFor(state){
  module('app', 'index.html', function($provide){
    $provide('state', state); 
  })
  inject(function($templateCache, $compile, $rootScope){
    page.element = $compile($templateCache.get('index.html'))($rootScope);
    $rootScope.$digest();
  });
}
```

### Mideway Object Inserting State Using a `$scope`.

Alternatively, state might be inserted directly into the scope (in this
case `$rootScope`) for initial testing, thus:

```javascript
function GIVEN_GnarlyPageFor(state){
  module('app', 'index.html')
  inject(function($templateCache, $compile, $rootScope){
    $rootScope.vm.state = state;
    page.element = $compile($templateCache.get('index.html'))($rootScope);
    $rootScope.$digest();
  });
}
```

Simulated Stimulus.
-------------------

Most stimulus can be accomplished directly using jQuery or jQlite and
DOM operations. For example, we can click on a button with the code:

```javacript
it('results in something when the button is clicked', function(){
  page.find('.buttonClass').click();
  expect(page.result).toBe('something');
})
```

Ordinarily, the actual clicking code would be embodied in the
`PAGEOBJECT`, but is spelled out here as an example.

Other operations may be more complex. Since browsers try to make it
difficult to type in fields with javascript as a security measure, we
may find it best, rather than by trying to simulate individual
key-presses, but by simulating the simulate typing a string into an
input elmeent, by:

-   assigning the string to the value attribute of the element

-   triggering an input event.

For example:

```javascript
it('results in something when "something" is typed into elmeent', function(){
  page.find('input.elementClass')
    .val('something')
    .trigger({type: 'input'});
  expect(page.result).toBe('something');
})
```
Again the details are typically hidden in the `PAGEOBJECT`.

Another example might be handling keydown events for a game. In this
case, where an `ng-keydown="vm.keydownHandler($event)"` is established.
You may wish to exercise the controller function with the following:

```javsscript
it('does something when the left arrow key is pressed', function(){
  page.find('.container').trigger({type: 'keydown', which: 37});
  expect(page.result).toBe('something');
}).
```

Other examples, for example clicks resulting in routing state changes,
may be best accomplished through simulation. You will see several
examples in the katas.
