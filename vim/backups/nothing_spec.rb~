require 'spec_helper'

module Nothing
  describe Nothing do

    describe 'natural numbers' do
      def ntoi n
        n[->x{x+1},0] 
      end
      it "0" do  ntoi(ZERO).should == 0 end 
      it "1" do  ntoi(ONE).should == 1 end 
      it "2" do ntoi(TWO).should == 2 end
      it "3" do ntoi(THREE).should == 3 end
      it "increment" do
        ntoi(INCREMENT[ZERO]).should == 1 
        ntoi(INCREMENT[INCREMENT[ZERO]]).should == 2 
        ntoi(INCREMENT[INCREMENT[INCREMENT[ZERO]]]).should == 3 
      end
      specify { pending { ZERO.should represent 0 } }
      specify { pending { ONE.should represent 1 } }
      specify { pending { TWO.should represent 2 } }
      specify { pending { THREE.should represent 3 } }

      specify { pending { TIMES[representation_of 3][-> s { s + 'o' }]['hell'].should == 'hellooo' } }
      specify { pending { INCREMENT[representation_of 2].should represent 2 + 1 } }
      specify { pending { ADD[representation_of 2][representation_of 3].should represent 2 + 3 } }
      specify { pending { MULTIPLY[representation_of 2][representation_of 3].should represent 2 * 3 } }
      specify { pending { POWER[representation_of 2][representation_of 3].should represent 2 ** 3 } }
      specify { pending { DECREMENT[representation_of 3].should represent 3 - 1 } }
      specify { pending { SUBTRACT[representation_of 3][representation_of 2].should represent 3 - 2 } }

      context 'with booleans' do
        (0..3).each do |n|
          specify { pending { IS_ZERO[representation_of n].should represent n.zero? } }
          specify { pending { IS_LESS_OR_EQUAL[representation_of n][representation_of 2].should represent n <= 2 } }
          specify { pending { IS_EQUAL[representation_of n][representation_of 2].should represent n == 2 } }
        end
      end

      context 'with recursion' do
        (0..5).zip([1, 1, 2, 6, 24, 120]) do |n, n_factorial|
          specify { pending { FACTORIAL[representation_of n].should represent n_factorial } }
        end

        [0, 1, 11, 27].product([1, 3, 11]) do |m, n|
          specify { pending { DIV[representation_of m][representation_of n].should represent m / n } }
          specify { pending { MOD[representation_of m][representation_of n].should represent m % n } }
        end
      end

      context 'with lists' do
        specify { pending { TO_DIGITS[representation_of 42].should represent [4, 2] } }
      end

      context 'with strings' do
        specify { pending { TO_STRING[representation_of 42].should represent '42' } }
      end
    end

    describe 'booleans' do
      specify { pending { TRUE.should represent true } }
      specify { pending { FALSE.should represent false } }

      let(:foo) { Object.new }
      let(:bar) { Object.new }

      [true, false].each do |b|
        specify { pending { IF[representation_of b][foo][bar].should equal(if b then foo else bar end) } }
        specify { pending { NOT[representation_of b].should represent !b } }

        [true, false].each do |a|
          specify { pending { AND[representation_of a][representation_of b].should represent a && b } }
          specify { pending { OR[representation_of a][representation_of b].should represent a || b } }
        end
      end
    end

    describe 'pairs' do
      specify { pending { PAIR[representation_of 3][representation_of 5].should represent Pair.new(3, 5) } }

      let(:foo) { Object.new }
      let(:bar) { Object.new }

      specify { pending { LEFT[PAIR[foo][bar]].should equal(foo) } }
      specify { pending { RIGHT[PAIR[foo][bar]].should equal(bar) } }
    end

    describe 'lists' do
      specify { pending { EMPTY.should represent [] } }
      specify { pending { UNSHIFT[representation_of [2, 3]][representation_of 1].should represent [1, 2, 3] } }

      specify { pending { IS_EMPTY[representation_of []].should represent true } }
      specify { pending { IS_EMPTY[representation_of [1]].should represent false } }
      specify { pending { FIRST[representation_of [1, 2, 3]].should represent 1 } }
      specify { pending { REST[representation_of [1, 2, 3]].should represent [2, 3] } }

      specify { pending { RANGE[representation_of 2][representation_of 8].should represent [2, 3, 4, 5, 6, 7, 8] } }
      specify { pending { SUM[representation_of [2, 2, 3]].should represent 7 } }
      specify { pending { PRODUCT[representation_of [2, 2, 3]].should represent 12 } }
      specify { pending { CONCAT[representation_of [1, 2]][representation_of [3, 2]].should represent [1, 2, 3, 2] } }
      specify { pending { PUSH[representation_of [1, 2]][representation_of 3].should represent [1, 2, 3] } }
      specify { pending { REVERSE[representation_of [1, 2, 3]].should represent [3, 2, 1] } }

      specify { pending { INCREMENT_ALL[representation_of [1, 2, 3]].should represent [2, 3, 4] } }
      specify { pending { DOUBLE_ALL[representation_of [1, 2, 3]].should represent [2, 4, 6] } }
    end

    describe 'FizzBuzz' do
      def fizzbuzz(m)
        (1..m).map { |n| (n % 15).zero? ? 'FizzBuzz' : (n % 3).zero? ? 'Fizz' : (n % 5).zero? ? 'Buzz' : n.to_s }
      end

      specify { pending { FIZZBUZZ[representation_of 30].should represent fizzbuzz(30) } }
    end
  end
end
