#!/usr/bin/env coffee

express = require 'express'
coffee = require 'coffee-script'

fs = require 'fs'
cli = require 'cli-color'
str = (require './src/display/str').str

Loc = (require './src/entities/loc').Loc
Node = (require './src/entities/node').Node
Issue = (require './src/entities/issue').Issue
Document = (require './src/entities/document').Document
Fact = (require './src/entities/fact').Fact
KeypressListener = (require './src/keyListener').KeypressListener

stdout = process.stdout

class LocPresenter
  constructor: (@loc) ->
  screenDisplays: ->
    @loc.upmost().flatMap (e,i,loc)=>
      @index = i if @_isSelected(loc)
      @displayOneLoc(loc)
  scrolledDisplays: (height) ->
    @screenDisplays()[Math.max(0,@index-height+1)...Math.max(height,@index+1)]
  webDisplay: -> (@loc.upmost().treeTagMap (t,loc) =>
    selected: if @_isSelected(loc) then "selected" else ""
    depth: loc.depth
    openString: @_openStringHtmlEntities loc
    decoratorString: @decoratorString loc
    text: t.text()).root()
  displayOneLoc: (loc) ->
    @gutterString(loc) +
      @headerString(loc) + ' ' +
      @tagString(loc)
  decoratorString: (loc) -> str.harvardDecoration loc.depth, loc.index
  gutterString: (loc) -> if @_isSelected(loc) then '==>' else '   '
  openString: (loc) ->
    if loc._isLeaf()
      ' '
    else if @_isOpen(loc)
      '\u25BC'
    else
      '\u25B6'
  headerString: (loc) ->
    str.rjust(@decoratorString(loc) + @openString(loc),
      loc.depth*6,
      if @_isSelected(loc) then '.' else ' ')
  tagString: (loc) ->
    if loc.isRoot()
      cli.bold(loc.tag().text())
    else
      loc.tag().text()
  _isSelected: (loc) -> loc.node.tag.id == @loc.node.tag.id
  _isOpen: (loc) -> not loc.tag()?.closed
  _openStringHtmlEntities: (loc) ->
    if loc._isLeaf()
      ' '
    else if @_isOpen(loc)
      '&#9660;'
    else
      '&#9658;'

class Screen
  constructor: (@stream=process.stdout) ->

  write: (str) ->
    @stream.write str

  drawScreen: ->
    @_resetBorderDimensions()
    @_homeAndHideCursor()
    @_drawTopBox()
    @_drawFrameRow() for i in [1..@bor.h-6]
    @_drawBottomBox()

  drawOutline: (loc) ->
    @_resetBorderDimensions()
    @_resetOutlineDimensions()
    screenDisplays = (new LocPresenter loc).scrolledDisplays(@out.h)
    screenDisplays.map (e, idx) =>
      stdout.write "#{cli.moveTo @out.lft, @out.top+idx}#{str.ljust e, @out.w}"
    for idx in [screenDisplays.length...@out.h]
      stdout.write "#{cli.moveTo @out.lft, @out.top+idx}#{str.repeat ' ', @out.w}"

  drawDisplay: (loc) ->
    @drawScreen()
    @drawOutline(loc)

  displayCursorFor: (string) ->
    @write cli.moveTo(2, @bor.h-2) + str.ljust "====> #{string}", @bor.w-4

  positionCursorAdding: (string, add) ->
    @write cli.moveTo(8+string.length, @bor.h-2) + add + str.showCursor

  beep: ->
    @write cli.beep

  _resetScreen: ->
    @write cli.reset

  _resetBorderDimensions: ->
    width = cli.width
    @bor =
      color: cli.green.bgXterm(240)
      w: cli.width
      h: cli.height
      hl: str.repeat '-', width - 2
      topText: cli.bold str.fjust 'E C A S E B A S E   I S S U E   O U T L I N E R', width-2
      botText: str.fjust 'Copyright Â© 2013 Andrew C. Greenberg All Rights Reserved', width-2

  _resetOutlineDimensions: ->
    @out =
      top: 4
      lft: 2
      h: @bor.h-8
      w: @bor.w-4

  _homeAndHideCursor: ->
    @write cli.moveTo(0,0) + str.hideCursor

  _drawTopBox: ->
    @write @bor.color "+#{@bor.hl}+"
    @write @bor.color "|#{@bor.topText}|"
    @write @bor.color "+#{@bor.hl}+"

  _drawFrameRow: ->
    @write(@bor.color("| ") + str.repeat(' ', @bor.w-4) + @bor.color(" |"))

  _drawBottomBox: ->
    @write @bor.color "+#{@bor.hl}+"
    @write @bor.color "|#{@bor.botText}|"
    @write @bor.color "+#{@bor.hl}+"

class State
  constructor: (@loc, @issueRepo, @documentRepo, @factRepo) ->

  do: (cmd) ->
    @apply(cmd)

  apply: (cmd) ->
    result = cmd()
    if result?
      @loc = result
    else
      stdout.write cli.beep

  loadJSON: (json)->
    db = try
      JSON.parse json
    catch error
      {
        issues: [{id:0, text: error}]
        outline: {tag:{id: 0}, children: []}
        documents: []
        facts: []
      }
    @_loadFromDB(db)

  _loadFromDB: (db)->
    @issueRepo.reset()
    new @issueRepo hash.text, hash.id for hash in db.issues
    (new @documentRepo hash.name, hash.description, hash.mime,
      hash.url, hash.filename, hash.size, hash.id) for hash in (db.documents)
    (new @factRepo hash.title, hash.caption, hash.description, hash.documentID,
      hash.durationEvent, hash.start, hash.latestStart, hash.earliestEnd, hash.end,
      hash.link, hash.textColor, hash.color, hash.className, hash.id) for hash in (db.facts)
    @loc = (new Loc @_newNodeFrom db.outline)
    @loc = @loc.upmost().openAll()

  dumpJSON: ->
    JSON.stringify {
      issues: @issueRepo.all()
      documents: @documentRepo.all()
      facts: @factRepo.all()
      outline: @loc.root()
    }, undefined, null

  toggleOpen: ->
    unless @loc._isLeaf()
      @loc = @loc.replace @_node @_merge(@loc.node.tag, {closed: not @loc.node.tag.closed}), @loc.node.children

  _newNodeFrom: (outline) ->
    console.log "_newNodeFrom(#{outline.tag.id} -- #{@issueRepo.find(outline.tag.id)})"
    @issueRepo.find(outline.tag.id).toNode outline.children.map (e) => @_newNodeFrom(e)

  _node: (tag=@loc.node.tag, children=[]) ->
    new @loc.node.constructor tag, children

  _mergeTag: (updates) ->
    _node @_merge(@loc.tag, update), @loc.tag.children()

  _merge: (source, updates) ->
    result = {}
    result[key] = value for key, value of source
    result[key] = value for key, value of updates
    result

class InsertionMode
  constructor: (@state, @screen, @normalMode, @callback) ->
    @string = ''
    @screen.displayCursorFor(@string)
    @screen.positionCursorAdding @string, ''

  handler: (ch, key, mode) ->
    @screen.displayCursorFor(@string)
    switch key?.name
      when 'enter'
        @callback(@string)
        @screen.drawDisplay(@state.loc)
        @normalMode
      when 'escape'
        @screen.drawDisplay(@state.loc)
        @normalMode
      when 'backspace', 'left'
        if @string.length > 0
          @string = @string[...@string.length-1]
          @screen.positionCursorAdding @string, ' '
        @screen.positionCursorAdding @string, ''
        @
      else
        @screen.positionCursorAdding @string, ch
        @string += ch
        @

class NormalMode
  constructor: (@state, @screen) ->
  handler: (ch, key, mode) ->
    switch key?.name
      when "e"
        @state.loadJSON fs.readFileSync("outline.json", "utf8")
        @screen.drawDisplay(@state.loc)
      when "w" then fs.writeFileSync "outline.json", @state.dumpJSON()
      when "r" then @screen.drawDisplay(@state.loc)
      when "h", 'left' then @state.do => @state.loc.up()
      when 'j', 'down'
        if key.shift
          @state.do =>@state.loc.right()
        else
          @state.do =>@state.loc.next()
      when 'k', 'up'
        if key.shift
          @state.do =>@state.loc.left()
        else
          @state.do =>@state.loc.prev()
      when "l", 'right' then @state.do => @state.loc.down()
      when 'p'
        if key.shift
          @state.do =>@state.loc.moveBefore()
        else
          @state.do =>@state.loc.moveChild()
      when 'tab'
        @state.do
        if key.shift
          @state.do =>@state.loc.outdent()
        else
          @state.do =>@state.loc.indent()
      when 'space' then @state.toggleOpen()
      when 'a'
        if key.shift and not @state.loc.isRoot()
          return new InsertionMode @state, @screen, @, (string) => @state.do =>
            @state.loc.insertBefore(@state.issueRepo.createNode string)?.left()
        else if not key.shift
          return new InsertionMode @state, @screen, @, (string) => @state.do =>
            newNode = @state.issueRepo.createNode string
            @state.loc.insertAfter(newNode)?.right() ?
            @state.loc.insertChild(newNode).down()
      else @screen.beep()
    @screen.drawOutline(@state.loc)
    @

class WebServer
  constructor: (state, @app=express()) ->
    @app.engine 'ejs', require 'ejs-locals'
    @app.set 'port', process.env.PORT || 3000
    @app.set 'views', __dirname + '/views'
    @app.set 'view engine', 'ejs'
    @app.use require('connect-assets')(build: true)
    @app.use express.static __dirname + '/public'
    @app.use express.favicon()
    @app.use express.logger('dev')
    @app.use express.bodyParser()
    @app.use express.methodOverride()
    @app.use express.cookieParser('wizardwerdna')
    @app.use express.session()
    @app.locals.css = css
    @app.locals.js = js
    @app.locals.marked = require('marked')
    @app.locals.require = require
    css.root = 'stylesheets'
    js.root  = 'javascripts'
    @app.get '/', (req, res) ->
      res.render 'outline', outline:
        (new LocPresenter state.loc).
          webDisplay()

    @app.get '/issues', (req, res) ->
      res.render 'issues',
        issues: state.issueRepo.all()

    @app.get '/facts', (req, res) ->
      res.render 'facts',
        facts: state.factRepo.all()

    @app.get '/evidence', (req, res) ->
      res.render 'evidence',
        documents: state.documentRepo.all()

  listen: (port=1337) ->
    @app.listen(port)

main = ->

  state = new State null, Issue.reset(), Document.reset(), Fact.reset()
  state.loadJSON fs.readFileSync 'outline.json'

  screen = new Screen
  screen.drawScreen()
  screen.drawOutline(state.loc)

  normalMode = new NormalMode state, screen
  keyboard = new KeypressListener (ch, key, mode) =>
    mode or= normalMode
    mode = mode.handler(ch, key, mode, state)
    mode
  keyboard.listen()

  (new WebServer state).listen(1337)

main()
